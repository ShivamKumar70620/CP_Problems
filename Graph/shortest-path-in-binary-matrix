https://leetcode.com/problems/shortest-path-in-binary-matrix/

code:-

[1] - TLE (my approach)

class Solution {
public:
    // int count;
    void dfs(int i,int j,int n,vector<vector<int>>& grid,vector<vector<bool>> &vis,int step,int &count){
        if(i==n-1 && j==n-1)
        {
            cout<<step<<endl;
            if(count>step)
                count = step;
            return;
        }
        vis[i][j] = 1;
        if(i-1>=0 && !vis[i-1][j] && grid[i-1][j]==0){
            dfs(i-1,j,n,grid,vis,step+1,count);
        }
        if(i-1>=0 && j-1>=0 && !vis[i-1][j-1] && grid[i-1][j-1]==0){
            dfs(i-1,j-1,n,grid,vis,step+1,count);
        }
        if(j-1>=0 && !vis[i][j-1] && grid[i][j-1]==0){
            dfs(i,j-1,n,grid,vis,step+1,count);
        }
        if(i+1<=n-1 && j-1>=0 && !vis[i+1][j-1] && grid[i+1][j-1]==0) {
            dfs(i+1,j-1,n,grid,vis,step+1,count);
        }
        if(i+1<=n-1 && !vis[i+1][j] && grid[i+1][j]==0){
            dfs(i+1,j,n,grid,vis,step+1,count);
        }
        if(i+1<=n-1 && j+1<=n-1 && !vis[i+1][j+1] && grid[i+1][j+1]==0){
            dfs(i+1,j+1,n,grid,vis,step+1,count);
        }
        if(j+1<=n-1 && !vis[i][j+1] && grid[i][j+1]==0){
            dfs(i,j+1,n,grid,vis,step+1,count);
        }
        if(i-1>=0 && j+1<=n-1 &&!vis[i-1][j+1] && grid[i-1][j+1]==0){
            dfs(i-1,j+1,n,grid,vis,step+1,count);
        }
        vis[i][j] = 0;
        
    }
    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
        if(grid[0][0]==1)
            return -1;
        // queue<vector<int>> q;
        int n = grid.size();
        // q.push({0,0});
        vector<vector<bool>> vis(n,vector<bool>(n,false));
        // int count = INT_MAX;
        // int step = 0;
        int count = INT_MAX;
        int step = 1;
        dfs(0,0,n,grid,vis,step,count);
        return count==INT_MAX?-1:count;
        
    }
};
